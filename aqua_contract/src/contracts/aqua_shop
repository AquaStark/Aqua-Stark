
// #[test]
// fn test_end_auction_with_winner() {
//     let seller = contract_address_const::<'seller'>();
//     let bidder = contract_address_const::<'bidder'>();
//     let ndef = namespace_def();
//     let mut world = spawn_test_world([ndef].span());
//     world.sync_perms_and_inits(contract_defs());

//     let (contract_address, _) = world.dns(@"AquaStark").unwrap();
//     let actions_system = IAquaStarkDispatcher { contract_address };

//     // Seller creates fish and starts auction
//     testing::set_contract_address(seller);
//     actions_system.register('seller');
//     let fish = actions_system.new_fish(1, Species::GoldFish);
//     let auction = actions_system.start_auction(fish.id, 3600, 100);

//     // Bidder places bid
//     testing::set_contract_address(bidder);
//     actions_system.register('bidder');
//     let bid_amount = 150;
//     actions_system.place_bid(auction.auction_id, bid_amount);

//     // Fast forward time to end auction
//     testing::set_block_timestamp(auction.end_time + 1);

//     // End auction
//     testing::set_contract_address(seller);
//     actions_system.end_auction(auction.auction_id);

//     // Verify auction is closed
//     let updated_auction = actions_system.get_auction_by_id(auction.auction_id);
//     assert(!updated_auction.active, 'Auction should be inactive');

//     // Verify fish ownership transferred
//     let fish_owner = actions_system.get_fish_owner(fish.id);
//     assert(fish_owner == bidder, 'Fish should belong to bidder');

//     // Verify fish is unlocked
//     let fish_owner_model: FishOwner = world.read_model(fish.id);
//     assert(!fish_owner_model.locked, 'Fish should be unlocked');
// }

// #[test]
// fn test_end_auction_no_winner() {
//     let seller = contract_address_const::<'seller'>();
//     let ndef = namespace_def();
//     let mut world = spawn_test_world([ndef].span());
//     world.sync_perms_and_inits(contract_defs());

//     let (contract_address, _) = world.dns(@"AquaStark").unwrap();
//     let actions_system = IAquaStarkDispatcher { contract_address };

//     // Seller creates fish and starts auction
//     testing::set_contract_address(seller);
//     actions_system.register('seller');
//     let fish = actions_system.new_fish(1, Species::GoldFish);
//     let auction = actions_system.start_auction(fish.id, 3600, 100);

//     // Fast forward time to end auction
//     testing::set_block_timestamp(auction.end_time + 1);

//     // End auction with no bids
//     actions_system.end_auction(auction.auction_id);

//     // Verify auction is closed
//     let updated_auction = actions_system.get_auction_by_id(auction.auction_id);
//     assert(!updated_auction.active, 'Auction should be inactive');

//     // Verify fish returned to seller
//     let fish_owner = actions_system.get_fish_owner(fish.id);
//     assert!(fish_owner == seller, "Fish should be returned to seller");

//     // Verify fish is unlocked
//     let fish_owner_model: FishOwner = world.read_model(fish.id);
//     assert(!fish_owner_model.locked, 'Fish should be unlocked');
// }

// #[test]
// fn test_get_active_auctions() {
//     let seller = contract_address_const::<'seller'>();
//     let ndef = namespace_def();
//     let mut world = spawn_test_world([ndef].span());
//     world.sync_perms_and_inits(contract_defs());

//     let (contract_address, _) = world.dns(@"AquaStark").unwrap();
//     let actions_system = IAquaStarkDispatcher { contract_address };

//     testing::set_contract_address(seller);
//     actions_system.register('seller');

//     // Create 3 fish and start auctions
//     let fish1 = actions_system.new_fish(1, Species::GoldFish);
//     let auction1 = actions_system.start_auction(fish1.id, 3600, 100);

//     let fish2 = actions_system.new_fish(1, Species::Betta);
//     let auction2 = actions_system.start_auction(fish2.id, 7200, 200);

//     let fish3 = actions_system.new_fish(1, Species::AngelFish);
//     let auction3 = actions_system.start_auction(fish3.id, 1800, 50);

//     // End one auction
//     testing::set_block_timestamp(auction3.end_time + 1);
//     actions_system.end_auction(auction3.auction_id);

//     // Get active auctions
//     let active_auctions = actions_system.get_active_auctions();

//     // Should return 2 active auctions (auction1 and auction2)
//     assert(active_auctions.len() == 2, 'Should have 2 active auctions');

//     // Verify correct auctions are active
//     let mut found_auction1 = false;
//     let mut found_auction2 = false;

//     for auction in active_auctions {
//         if auction.auction_id == auction1.auction_id {
//             found_auction1 = true;
//         }
//         if auction.auction_id == auction2.auction_id {
//             found_auction2 = true;
//         }
//     };

//     assert!(found_auction1, "Auction1 not found in active auctions");
//     assert!(found_auction2, "Auction2 not found in active auctions");
// }

// #[test]
// fn test_auction_events() {
//     let seller = contract_address_const::<'seller'>();
//     let bidder = contract_address_const::<'bidder'>();
//     let ndef = namespace_def();
//     let mut world = spawn_test_world([ndef].span());
//     world.sync_perms_and_inits(contract_defs());

//     let (contract_address, _) = world.dns(@"AquaStark").unwrap();
//     let actions_system = IAquaStarkDispatcher { contract_address };

//     // Register seller and create fish
//     testing::set_contract_address(seller);
//     actions_system.register('seller');
//     let fish = actions_system.new_fish(1, Species::GoldFish);

//     // Start auction and check event
//     let auction = actions_system.start_auction(fish.id, 3600, 100);
//     // let auction_started_events = world.get_events::<AuctionStarted>();
//     // assert(auction_started_events.len() == 1, 'AuctionStarted event not emitted');
//     // assert(
//     //     auction_started_events[0].auction_id == auction.auction_id,
//     //     'Event auction ID mismatch'
//     // );

//     // Register bidder and place bid
//     testing::set_contract_address(bidder);
//     actions_system.register('bidder');
//     actions_system.place_bid(auction.auction_id, 150);

//     // Check BidPlaced event
//     // let bid_placed_events = world.get_events::<BidPlaced>();
//     // assert(bid_placed_events.len() == 1, 'BidPlaced event not emitted');
//     // assert(
//     //     bid_placed_events[0].auction_id == auction.auction_id,
//     //     'Event auction ID mismatch'
//     // );
//     // assert(bid_placed_events[0].amount == 150, 'Event bid amount mismatch');

//     // End auction and check event
//     testing::set_block_timestamp(auction.end_time + 1);
//     testing::set_contract_address(seller);
//     actions_system.end_auction(auction.auction_id);

//     // Check AuctionEnded event
//     // let auction_ended_events = world.get_events::<AuctionEnded>();
//     // assert(auction_ended_events.len() == 1, 'AuctionEnded event not emitted');
//     // assert(
//     //     auction_ended_events[0].auction_id == auction.auction_id,
//     //     'Event auction ID mismatch'
//     // );
//     // assert(
//     //     auction_ended_events[0].winner == Option::Some(bidder),
//     //     'Event winner mismatch'
//     // );
//     // assert(
//     //     auction_ended_events[0].final_price == 150,
//     //     'Event final price mismatch'
//     // );
// }
// }


